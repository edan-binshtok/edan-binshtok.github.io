{"version":3,"file":"platform-browser.umd.js","sources":["../../../../../external/npm/node_modules/tslib/tslib.es6.js","../../../../../packages/platform-browser/src/dom/dom_adapter.ts","../../../../../packages/platform-browser/src/browser/generic_browser_adapter.ts","../../../../../packages/platform-browser/src/browser/browser_adapter.ts","../../../../../packages/platform-browser/src/browser/location/history.ts","../../../../../packages/platform-browser/src/browser/location/browser_platform_location.ts","../../../../../packages/platform-browser/src/browser/server-transition.ts","../../../../../packages/platform-browser/src/browser/testability.ts","../../../../../packages/platform-browser/src/dom/util.ts","../../../../../packages/platform-browser/src/dom/debug/ng_probe.ts","../../../../../packages/platform-browser/src/dom/events/event_manager.ts","../../../../../packages/platform-browser/src/dom/shared_styles_host.ts","../../../../../packages/platform-browser/src/dom/dom_renderer.ts","../../../../../packages/platform-browser/src/dom/events/dom_events.ts","../../../../../packages/platform-browser/src/dom/events/hammer_gestures.ts","../../../../../packages/platform-browser/src/dom/events/key_events.ts","../../../../../packages/platform-browser/src/security/dom_sanitization_service.ts","../../../../../packages/platform-browser/src/browser.ts","../../../../../packages/platform-browser/src/browser/meta.ts","../../../../../packages/platform-browser/src/browser/title.ts","../../../../../packages/platform-browser/src/browser/tools/browser.ts","../../../../../packages/platform-browser/src/browser/tools/common_tools.ts","../../../../../packages/platform-browser/src/browser/tools/tools.ts","../../../../../packages/platform-browser/src/browser/transfer_state.ts","../../../../../packages/platform-browser/src/dom/debug/by.ts","../../../../../packages/platform-browser/src/private_export.ts","../../../../../packages/platform-browser/src/version.ts","../../../../../packages/platform-browser/src/platform-browser.ts","../../../../../packages/platform-browser/public_api.ts","../../../../../packages/platform-browser/index.ts","../../../../../packages/platform-browser/platform-browser.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/core';\n\nlet _DOM: DomAdapter = null !;\n\nexport function getDOM() {\n  return _DOM;\n}\n\nexport function setDOM(adapter: DomAdapter) {\n  _DOM = adapter;\n}\n\nexport function setRootDomAdapter(adapter: DomAdapter) {\n  if (!_DOM) {\n    _DOM = adapter;\n  }\n}\n\n/* tslint:disable:requireParameterType */\n/**\n * Provides DOM operations in an environment-agnostic way.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\nexport abstract class DomAdapter {\n  public resourceLoaderType: Type<any> = null !;\n  abstract hasProperty(element: any, name: string): boolean;\n  abstract setProperty(el: Element, name: string, value: any): any;\n  abstract getProperty(el: Element, name: string): any;\n  abstract invoke(el: Element, methodName: string, args: any[]): any;\n\n  abstract logError(error: any): any;\n  abstract log(error: any): any;\n  abstract logGroup(error: any): any;\n  abstract logGroupEnd(): any;\n\n  /**\n   * Maps attribute names to their corresponding property names for cases\n   * where attribute name doesn't match property name.\n   */\n  get attrToPropMap(): {[key: string]: string} { return this._attrToPropMap; }\n  set attrToPropMap(value: {[key: string]: string}) { this._attrToPropMap = value; }\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _attrToPropMap !: {[key: string]: string};\n\n  abstract contains(nodeA: any, nodeB: any): boolean;\n  abstract parse(templateHtml: string): any;\n  abstract querySelector(el: any, selector: string): any;\n  abstract querySelectorAll(el: any, selector: string): any[];\n  abstract on(el: any, evt: any, listener: any): any;\n  abstract onAndCancel(el: any, evt: any, listener: any): Function;\n  abstract dispatchEvent(el: any, evt: any): any;\n  abstract createMouseEvent(eventType: any): any;\n  abstract createEvent(eventType: string): any;\n  abstract preventDefault(evt: any): any;\n  abstract isPrevented(evt: any): boolean;\n  abstract getInnerHTML(el: any): string;\n  /** Returns content if el is a <template> element, null otherwise. */\n  abstract getTemplateContent(el: any): any;\n  abstract getOuterHTML(el: any): string;\n  abstract nodeName(node: any): string;\n  abstract nodeValue(node: any): string|null;\n  abstract type(node: any): string;\n  abstract content(node: any): any;\n  abstract firstChild(el: any): Node|null;\n  abstract nextSibling(el: any): Node|null;\n  abstract parentElement(el: any): Node|null;\n  abstract childNodes(el: any): Node[];\n  abstract childNodesAsList(el: any): Node[];\n  abstract clearNodes(el: any): any;\n  abstract appendChild(el: any, node: any): any;\n  abstract removeChild(el: any, node: any): any;\n  abstract replaceChild(el: any, newNode: any, oldNode: any): any;\n  abstract remove(el: any): Node;\n  abstract insertBefore(parent: any, ref: any, node: any): any;\n  abstract insertAllBefore(parent: any, ref: any, nodes: any): any;\n  abstract insertAfter(parent: any, el: any, node: any): any;\n  abstract setInnerHTML(el: any, value: any): any;\n  abstract getText(el: any): string|null;\n  abstract setText(el: any, value: string): any;\n  abstract getValue(el: any): string;\n  abstract setValue(el: any, value: string): any;\n  abstract getChecked(el: any): boolean;\n  abstract setChecked(el: any, value: boolean): any;\n  abstract createComment(text: string): any;\n  abstract createTemplate(html: any): HTMLElement;\n  abstract createElement(tagName: any, doc?: any): HTMLElement;\n  abstract createElementNS(ns: string, tagName: string, doc?: any): Element;\n  abstract createTextNode(text: string, doc?: any): Text;\n  abstract createScriptTag(attrName: string, attrValue: string, doc?: any): HTMLElement;\n  abstract createStyleElement(css: string, doc?: any): HTMLStyleElement;\n  abstract createShadowRoot(el: any): any;\n  abstract getShadowRoot(el: any): any;\n  abstract getHost(el: any): any;\n  abstract getDistributedNodes(el: any): Node[];\n  abstract clone /*<T extends Node>*/ (node: Node /*T*/): Node /*T*/;\n  abstract getElementsByClassName(element: any, name: string): HTMLElement[];\n  abstract getElementsByTagName(element: any, name: string): HTMLElement[];\n  abstract classList(element: any): any[];\n  abstract addClass(element: any, className: string): any;\n  abstract removeClass(element: any, className: string): any;\n  abstract hasClass(element: any, className: string): boolean;\n  abstract setStyle(element: any, styleName: string, styleValue: string): any;\n  abstract removeStyle(element: any, styleName: string): any;\n  abstract getStyle(element: any, styleName: string): string;\n  abstract hasStyle(element: any, styleName: string, styleValue?: string): boolean;\n  abstract tagName(element: any): string;\n  abstract attributeMap(element: any): Map<string, string>;\n  abstract hasAttribute(element: any, attribute: string): boolean;\n  abstract hasAttributeNS(element: any, ns: string, attribute: string): boolean;\n  abstract getAttribute(element: any, attribute: string): string|null;\n  abstract getAttributeNS(element: any, ns: string, attribute: string): string|null;\n  abstract setAttribute(element: any, name: string, value: string): any;\n  abstract setAttributeNS(element: any, ns: string, name: string, value: string): any;\n  abstract removeAttribute(element: any, attribute: string): any;\n  abstract removeAttributeNS(element: any, ns: string, attribute: string): any;\n  abstract templateAwareRoot(el: any): any;\n  abstract createHtmlDocument(): HTMLDocument;\n  abstract getDefaultDocument(): Document;\n  abstract getBoundingClientRect(el: any): any;\n  abstract getTitle(doc: Document): string;\n  abstract setTitle(doc: Document, newTitle: string): any;\n  abstract elementMatches(n: any, selector: string): boolean;\n  abstract isTemplateElement(el: any): boolean;\n  abstract isTextNode(node: any): boolean;\n  abstract isCommentNode(node: any): boolean;\n  abstract isElementNode(node: any): boolean;\n  abstract hasShadowRoot(node: any): boolean;\n  abstract isShadowRoot(node: any): boolean;\n  abstract importIntoDoc /*<T extends Node>*/ (node: Node /*T*/): Node /*T*/;\n  abstract adoptNode /*<T extends Node>*/ (node: Node /*T*/): Node /*T*/;\n  abstract getHref(element: any): string;\n  abstract getEventKey(event: any): string;\n  abstract resolveAndSetHref(element: any, baseUrl: string, href: string): any;\n  abstract supportsDOMEvents(): boolean;\n  abstract supportsNativeShadowDOM(): boolean;\n  abstract getGlobalEventTarget(doc: Document, target: string): any;\n  abstract getHistory(): History;\n  abstract getLocation(): Location;\n  abstract getBaseHref(doc: Document): string|null;\n  abstract resetBaseElement(): void;\n  abstract getUserAgent(): string;\n  abstract setData(element: any, name: string, value: string): any;\n  abstract getComputedStyle(element: any): any;\n  abstract getData(element: any, name: string): string|null;\n  abstract supportsWebAnimation(): boolean;\n  abstract performanceNow(): number;\n  abstract getAnimationPrefix(): string;\n  abstract getTransitionEnd(): string;\n  abstract supportsAnimation(): boolean;\n\n  abstract supportsCookies(): boolean;\n  abstract getCookie(name: string): string|null;\n  abstract setCookie(name: string, value: string): any;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DomAdapter} from '../dom/dom_adapter';\n\n\n\n/**\n * Provides DOM operations in any browser environment.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\nexport abstract class GenericBrowserDomAdapter extends DomAdapter {\n  private _animationPrefix: string|null = null;\n  private _transitionEnd: string|null = null;\n  constructor() {\n    super();\n    try {\n      const element = this.createElement('div', document);\n      if (this.getStyle(element, 'animationName') != null) {\n        this._animationPrefix = '';\n      } else {\n        const domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];\n\n        for (let i = 0; i < domPrefixes.length; i++) {\n          if (this.getStyle(element, domPrefixes[i] + 'AnimationName') != null) {\n            this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';\n            break;\n          }\n        }\n      }\n\n      const transEndEventNames: {[key: string]: string} = {\n        WebkitTransition: 'webkitTransitionEnd',\n        MozTransition: 'transitionend',\n        OTransition: 'oTransitionEnd otransitionend',\n        transition: 'transitionend'\n      };\n\n      Object.keys(transEndEventNames).forEach((key: string) => {\n        if (this.getStyle(element, key) != null) {\n          this._transitionEnd = transEndEventNames[key];\n        }\n      });\n    } catch {\n      this._animationPrefix = null;\n      this._transitionEnd = null;\n    }\n  }\n\n  getDistributedNodes(el: HTMLElement): Node[] { return (<any>el).getDistributedNodes(); }\n  resolveAndSetHref(el: HTMLAnchorElement, baseUrl: string, href: string) {\n    el.href = href == null ? baseUrl : baseUrl + '/../' + href;\n  }\n  supportsDOMEvents(): boolean { return true; }\n  supportsNativeShadowDOM(): boolean {\n    return typeof(<any>document.body).createShadowRoot === 'function';\n  }\n  getAnimationPrefix(): string { return this._animationPrefix ? this._animationPrefix : ''; }\n  getTransitionEnd(): string { return this._transitionEnd ? this._transitionEnd : ''; }\n  supportsAnimation(): boolean {\n    return this._animationPrefix != null && this._transitionEnd != null;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ÉµparseCookieValue as parseCookieValue} from '@angular/common';\nimport {Éµglobal as global} from '@angular/core';\n\nimport {setRootDomAdapter} from '../dom/dom_adapter';\n\nimport {GenericBrowserDomAdapter} from './generic_browser_adapter';\n\nconst _attrToPropMap = {\n  'class': 'className',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex',\n};\n\nconst DOM_KEY_LOCATION_NUMPAD = 3;\n\n// Map to convert some key or keyIdentifier values to what will be returned by getEventKey\nconst _keyMap: {[k: string]: string} = {\n  // The following values are here for cross-browser compatibility and to match the W3C standard\n  // cf http://www.w3.org/TR/DOM-Level-3-Events-key/\n  '\\b': 'Backspace',\n  '\\t': 'Tab',\n  '\\x7F': 'Delete',\n  '\\x1B': 'Escape',\n  'Del': 'Delete',\n  'Esc': 'Escape',\n  'Left': 'ArrowLeft',\n  'Right': 'ArrowRight',\n  'Up': 'ArrowUp',\n  'Down': 'ArrowDown',\n  'Menu': 'ContextMenu',\n  'Scroll': 'ScrollLock',\n  'Win': 'OS'\n};\n\n// There is a bug in Chrome for numeric keypad keys:\n// https://code.google.com/p/chromium/issues/detail?id=155654\n// 1, 2, 3 ... are reported as A, B, C ...\nconst _chromeNumKeyPadMap = {\n  'A': '1',\n  'B': '2',\n  'C': '3',\n  'D': '4',\n  'E': '5',\n  'F': '6',\n  'G': '7',\n  'H': '8',\n  'I': '9',\n  'J': '*',\n  'K': '+',\n  'M': '-',\n  'N': '.',\n  'O': '/',\n  '\\x60': '0',\n  '\\x90': 'NumLock'\n};\n\nconst nodeContains: (this: Node, other: Node) => boolean = (() => {\n  if (global['Node']) {\n    return global['Node'].prototype.contains || function(this: Node, node: any) {\n      return !!(this.compareDocumentPosition(node) & 16);\n    };\n  }\n\n  return undefined as any;\n})();\n\n/**\n * A `DomAdapter` powered by full browser DOM APIs.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\n/* tslint:disable:requireParameterType no-console */\nexport class BrowserDomAdapter extends GenericBrowserDomAdapter {\n  parse(templateHtml: string) { throw new Error('parse not implemented'); }\n  static makeCurrent() { setRootDomAdapter(new BrowserDomAdapter()); }\n  hasProperty(element: Node, name: string): boolean { return name in element; }\n  setProperty(el: Node, name: string, value: any) { (<any>el)[name] = value; }\n  getProperty(el: Node, name: string): any { return (<any>el)[name]; }\n  invoke(el: Node, methodName: string, args: any[]): any { (<any>el)[methodName](...args); }\n\n  // TODO(tbosch): move this into a separate environment class once we have it\n  logError(error: string): void {\n    if (window.console) {\n      if (console.error) {\n        console.error(error);\n      } else {\n        console.log(error);\n      }\n    }\n  }\n\n  log(error: string): void {\n    if (window.console) {\n      window.console.log && window.console.log(error);\n    }\n  }\n\n  logGroup(error: string): void {\n    if (window.console) {\n      window.console.group && window.console.group(error);\n    }\n  }\n\n  logGroupEnd(): void {\n    if (window.console) {\n      window.console.groupEnd && window.console.groupEnd();\n    }\n  }\n\n  get attrToPropMap(): any { return _attrToPropMap; }\n\n  contains(nodeA: any, nodeB: any): boolean { return nodeContains.call(nodeA, nodeB); }\n  querySelector(el: HTMLElement, selector: string): any { return el.querySelector(selector); }\n  querySelectorAll(el: any, selector: string): any[] { return el.querySelectorAll(selector); }\n  on(el: Node, evt: any, listener: any) { el.addEventListener(evt, listener, false); }\n  onAndCancel(el: Node, evt: any, listener: any): Function {\n    el.addEventListener(evt, listener, false);\n    // Needed to follow Dart's subscription semantic, until fix of\n    // https://code.google.com/p/dart/issues/detail?id=17406\n    return () => { el.removeEventListener(evt, listener, false); };\n  }\n  dispatchEvent(el: Node, evt: any) { el.dispatchEvent(evt); }\n  createMouseEvent(eventType: string): MouseEvent {\n    const evt: MouseEvent = this.getDefaultDocument().createEvent('MouseEvent');\n    evt.initEvent(eventType, true, true);\n    return evt;\n  }\n  createEvent(eventType: any): Event {\n    const evt: Event = this.getDefaultDocument().createEvent('Event');\n    evt.initEvent(eventType, true, true);\n    return evt;\n  }\n  preventDefault(evt: Event) {\n    evt.preventDefault();\n    evt.returnValue = false;\n  }\n  isPrevented(evt: Event): boolean {\n    return evt.defaultPrevented || evt.returnValue != null && !evt.returnValue;\n  }\n  getInnerHTML(el: HTMLElement): string { return el.innerHTML; }\n  getTemplateContent(el: Node): Node|null {\n    return 'content' in el && this.isTemplateElement(el) ? (<any>el).content : null;\n  }\n  getOuterHTML(el: HTMLElement): string { return el.outerHTML; }\n  nodeName(node: Node): string { return node.nodeName; }\n  nodeValue(node: Node): string|null { return node.nodeValue; }\n  type(node: HTMLInputElement): string { return node.type; }\n  content(node: Node): Node {\n    if (this.hasProperty(node, 'content')) {\n      return (<any>node).content;\n    } else {\n      return node;\n    }\n  }\n  firstChild(el: Node): Node|null { return el.firstChild; }\n  nextSibling(el: Node): Node|null { return el.nextSibling; }\n  parentElement(el: Node): Node|null { return el.parentNode; }\n  childNodes(el: any): Node[] { return el.childNodes; }\n  childNodesAsList(el: Node): any[] {\n    const childNodes = el.childNodes;\n    const res = new Array(childNodes.length);\n    for (let i = 0; i < childNodes.length; i++) {\n      res[i] = childNodes[i];\n    }\n    return res;\n  }\n  clearNodes(el: Node) {\n    while (el.firstChild) {\n      el.removeChild(el.firstChild);\n    }\n  }\n  appendChild(el: Node, node: Node) { el.appendChild(node); }\n  removeChild(el: Node, node: Node) { el.removeChild(node); }\n  replaceChild(el: Node, newChild: Node, oldChild: Node) { el.replaceChild(newChild, oldChild); }\n  remove(node: Node): Node {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n    return node;\n  }\n  insertBefore(parent: Node, ref: Node, node: Node) { parent.insertBefore(node, ref); }\n  insertAllBefore(parent: Node, ref: Node, nodes: Node[]) {\n    nodes.forEach((n: any) => parent.insertBefore(n, ref));\n  }\n  insertAfter(parent: Node, ref: Node, node: any) { parent.insertBefore(node, ref.nextSibling); }\n  setInnerHTML(el: Element, value: string) { el.innerHTML = value; }\n  getText(el: Node): string|null { return el.textContent; }\n  setText(el: Node, value: string) { el.textContent = value; }\n  getValue(el: any): string { return el.value; }\n  setValue(el: any, value: string) { el.value = value; }\n  getChecked(el: any): boolean { return el.checked; }\n  setChecked(el: any, value: boolean) { el.checked = value; }\n  createComment(text: string): Comment { return this.getDefaultDocument().createComment(text); }\n  createTemplate(html: any): HTMLElement {\n    const t = this.getDefaultDocument().createElement('template');\n    t.innerHTML = html;\n    return t;\n  }\n  createElement(tagName: string, doc?: Document): HTMLElement {\n    doc = doc || this.getDefaultDocument();\n    return doc.createElement(tagName);\n  }\n  createElementNS(ns: string, tagName: string, doc?: Document): Element {\n    doc = doc || this.getDefaultDocument();\n    return doc.createElementNS(ns, tagName);\n  }\n  createTextNode(text: string, doc?: Document): Text {\n    doc = doc || this.getDefaultDocument();\n    return doc.createTextNode(text);\n  }\n  createScriptTag(attrName: string, attrValue: string, doc?: Document): HTMLScriptElement {\n    doc = doc || this.getDefaultDocument();\n    const el = <HTMLScriptElement>doc.createElement('SCRIPT');\n    el.setAttribute(attrName, attrValue);\n    return el;\n  }\n  createStyleElement(css: string, doc?: Document): HTMLStyleElement {\n    doc = doc || this.getDefaultDocument();\n    const style = <HTMLStyleElement>doc.createElement('style');\n    this.appendChild(style, this.createTextNode(css, doc));\n    return style;\n  }\n  createShadowRoot(el: HTMLElement): DocumentFragment { return (<any>el).createShadowRoot(); }\n  getShadowRoot(el: HTMLElement): DocumentFragment { return (<any>el).shadowRoot; }\n  getHost(el: HTMLElement): HTMLElement { return (<any>el).host; }\n  clone(node: Node): Node { return node.cloneNode(true); }\n  getElementsByClassName(element: any, name: string): HTMLElement[] {\n    return element.getElementsByClassName(name);\n  }\n  getElementsByTagName(element: any, name: string): HTMLElement[] {\n    return element.getElementsByTagName(name);\n  }\n  classList(element: any): any[] { return Array.prototype.slice.call(element.classList, 0); }\n  addClass(element: any, className: string) { element.classList.add(className); }\n  removeClass(element: any, className: string) { element.classList.remove(className); }\n  hasClass(element: any, className: string): boolean {\n    return element.classList.contains(className);\n  }\n  setStyle(element: any, styleName: string, styleValue: string) {\n    element.style[styleName] = styleValue;\n  }\n  removeStyle(element: any, stylename: string) {\n    // IE requires '' instead of null\n    // see https://github.com/angular/angular/issues/7916\n    element.style[stylename] = '';\n  }\n  getStyle(element: any, stylename: string): string { return element.style[stylename]; }\n  hasStyle(element: any, styleName: string, styleValue?: string|null): boolean {\n    const value = this.getStyle(element, styleName) || '';\n    return styleValue ? value == styleValue : value.length > 0;\n  }\n  tagName(element: any): string { return element.tagName; }\n  attributeMap(element: any): Map<string, string> {\n    const res = new Map<string, string>();\n    const elAttrs = element.attributes;\n    for (let i = 0; i < elAttrs.length; i++) {\n      const attrib = elAttrs.item(i);\n      res.set(attrib.name, attrib.value);\n    }\n    return res;\n  }\n  hasAttribute(element: Element, attribute: string): boolean {\n    return element.hasAttribute(attribute);\n  }\n  hasAttributeNS(element: Element, ns: string, attribute: string): boolean {\n    return element.hasAttributeNS(ns, attribute);\n  }\n  getAttribute(element: Element, attribute: string): string|null {\n    return element.getAttribute(attribute);\n  }\n  getAttributeNS(element: Element, ns: string, name: string): string|null {\n    return element.getAttributeNS(ns, name);\n  }\n  setAttribute(element: Element, name: string, value: string) { element.setAttribute(name, value); }\n  setAttributeNS(element: Element, ns: string, name: string, value: string) {\n    element.setAttributeNS(ns, name, value);\n  }\n  removeAttribute(element: Element, attribute: string) { element.removeAttribute(attribute); }\n  removeAttributeNS(element: Element, ns: string, name: string) {\n    element.removeAttributeNS(ns, name);\n  }\n  templateAwareRoot(el: Node): any { return this.isTemplateElement(el) ? this.content(el) : el; }\n  createHtmlDocument(): HTMLDocument {\n    return document.implementation.createHTMLDocument('fakeTitle');\n  }\n  getDefaultDocument(): Document { return document; }\n  getBoundingClientRect(el: Element): any {\n    try {\n      return el.getBoundingClientRect();\n    } catch {\n      return {top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0};\n    }\n  }\n  getTitle(doc: Document): string { return doc.title; }\n  setTitle(doc: Document, newTitle: string) { doc.title = newTitle || ''; }\n  elementMatches(n: any, selector: string): boolean {\n    if (this.isElementNode(n)) {\n      return n.matches && n.matches(selector) ||\n          n.msMatchesSelector && n.msMatchesSelector(selector) ||\n          n.webkitMatchesSelector && n.webkitMatchesSelector(selector);\n    }\n\n    return false;\n  }\n  isTemplateElement(el: Node): boolean {\n    return this.isElementNode(el) && el.nodeName === 'TEMPLATE';\n  }\n  isTextNode(node: Node): boolean { return node.nodeType === Node.TEXT_NODE; }\n  isCommentNode(node: Node): boolean { return node.nodeType === Node.COMMENT_NODE; }\n  isElementNode(node: Node): boolean { return node.nodeType === Node.ELEMENT_NODE; }\n  hasShadowRoot(node: any): boolean {\n    return node.shadowRoot != null && node instanceof HTMLElement;\n  }\n  isShadowRoot(node: any): boolean { return node instanceof DocumentFragment; }\n  importIntoDoc(node: Node): any { return document.importNode(this.templateAwareRoot(node), true); }\n  adoptNode(node: Node): any { return document.adoptNode(node); }\n  getHref(el: Element): string { return el.getAttribute('href') !; }\n\n  getEventKey(event: any): string {\n    let key = event.key;\n    if (key == null) {\n      key = event.keyIdentifier;\n      // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and\n      // Safari cf\n      // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces\n      if (key == null) {\n        return 'Unidentified';\n      }\n      if (key.startsWith('U+')) {\n        key = String.fromCharCode(parseInt(key.substring(2), 16));\n        if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {\n          // There is a bug in Chrome for numeric keypad keys:\n          // https://code.google.com/p/chromium/issues/detail?id=155654\n          // 1, 2, 3 ... are reported as A, B, C ...\n          key = (_chromeNumKeyPadMap as any)[key];\n        }\n      }\n    }\n\n    return _keyMap[key] || key;\n  }\n  getGlobalEventTarget(doc: Document, target: string): EventTarget|null {\n    if (target === 'window') {\n      return window;\n    }\n    if (target === 'document') {\n      return doc;\n    }\n    if (target === 'body') {\n      return doc.body;\n    }\n    return null;\n  }\n  getHistory(): History { return window.history; }\n  getLocation(): Location { return window.location; }\n  getBaseHref(doc: Document): string|null {\n    const href = getBaseElementHref();\n    return href == null ? null : relativePath(href);\n  }\n  resetBaseElement(): void { baseElement = null; }\n  getUserAgent(): string { return window.navigator.userAgent; }\n  setData(element: Element, name: string, value: string) {\n    this.setAttribute(element, 'data-' + name, value);\n  }\n  getData(element: Element, name: string): string|null {\n    return this.getAttribute(element, 'data-' + name);\n  }\n  getComputedStyle(element: any): any { return getComputedStyle(element); }\n  // TODO(tbosch): move this into a separate environment class once we have it\n  supportsWebAnimation(): boolean {\n    return typeof(<any>Element).prototype['animate'] === 'function';\n  }\n  performanceNow(): number {\n    // performance.now() is not available in all browsers, see\n    // http://caniuse.com/#search=performance.now\n    return window.performance && window.performance.now ? window.performance.now() :\n                                                          new Date().getTime();\n  }\n\n  supportsCookies(): boolean { return true; }\n\n  getCookie(name: string): string|null { return parseCookieValue(document.cookie, name); }\n\n  setCookie(name: string, value: string) {\n    // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does\n    // not clear other cookies.\n    document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n  }\n}\n\nlet baseElement: HTMLElement|null = null;\nfunction getBaseElementHref(): string|null {\n  if (!baseElement) {\n    baseElement = document.querySelector('base') !;\n    if (!baseElement) {\n      return null;\n    }\n  }\n  return baseElement.getAttribute('href');\n}\n\n// based on urlUtils.js in AngularJS 1\nlet urlParsingNode: any;\nfunction relativePath(url: any): string {\n  if (!urlParsingNode) {\n    urlParsingNode = document.createElement('a');\n  }\n  urlParsingNode.setAttribute('href', url);\n  return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :\n                                                       '/' + urlParsingNode.pathname;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function supportsState(): boolean {\n  return !!window.history.pushState;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT, LocationChangeListener, PlatformLocation} from '@angular/common';\nimport {Inject, Injectable} from '@angular/core';\n\nimport {getDOM} from '../../dom/dom_adapter';\n\nimport {supportsState} from './history';\n\n\n\n/**\n * `PlatformLocation` encapsulates all of the direct calls to platform APIs.\n * This class should not be used directly by an application developer. Instead, use\n * {@link Location}.\n */\n@Injectable()\nexport class BrowserPlatformLocation extends PlatformLocation {\n  // TODO(issue/24571): remove '!'.\n  public readonly location !: Location;\n  // TODO(issue/24571): remove '!'.\n  private _history !: History;\n\n  constructor(@Inject(DOCUMENT) private _doc: any) {\n    super();\n    this._init();\n  }\n\n  // This is moved to its own method so that `MockPlatformLocationStrategy` can overwrite it\n  /** @internal */\n  _init() {\n    (this as{location: Location}).location = getDOM().getLocation();\n    this._history = getDOM().getHistory();\n  }\n\n  getBaseHrefFromDOM(): string { return getDOM().getBaseHref(this._doc) !; }\n\n  onPopState(fn: LocationChangeListener): void {\n    getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('popstate', fn, false);\n  }\n\n  onHashChange(fn: LocationChangeListener): void {\n    getDOM().getGlobalEventTarget(this._doc, 'window').addEventListener('hashchange', fn, false);\n  }\n\n  get href(): string { return this.location.href; }\n  get protocol(): string { return this.location.protocol; }\n  get hostname(): string { return this.location.hostname; }\n  get port(): string { return this.location.port; }\n  get pathname(): string { return this.location.pathname; }\n  get search(): string { return this.location.search; }\n  get hash(): string { return this.location.hash; }\n  set pathname(newPath: string) { this.location.pathname = newPath; }\n\n  pushState(state: any, title: string, url: string): void {\n    if (supportsState()) {\n      this._history.pushState(state, title, url);\n    } else {\n      this.location.hash = url;\n    }\n  }\n\n  replaceState(state: any, title: string, url: string): void {\n    if (supportsState()) {\n      this._history.replaceState(state, title, url);\n    } else {\n      this.location.hash = url;\n    }\n  }\n\n  forward(): void { this._history.forward(); }\n\n  back(): void { this._history.back(); }\n\n  getState(): unknown { return this._history.state; }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {APP_INITIALIZER, ApplicationInitStatus, Inject, InjectionToken, Injector, StaticProvider} from '@angular/core';\n\nimport {getDOM} from '../dom/dom_adapter';\n\n/**\n * An id that identifies a particular application being bootstrapped, that should\n * match across the client/server boundary.\n */\nexport const TRANSITION_ID = new InjectionToken('TRANSITION_ID');\n\nexport function appInitializerFactory(transitionId: string, document: any, injector: Injector) {\n  return () => {\n    // Wait for all application initializers to be completed before removing the styles set by\n    // the server.\n    injector.get(ApplicationInitStatus).donePromise.then(() => {\n      const dom = getDOM();\n      const styles: any[] =\n          Array.prototype.slice.apply(dom.querySelectorAll(document, `style[ng-transition]`));\n      styles.filter(el => dom.getAttribute(el, 'ng-transition') === transitionId)\n          .forEach(el => dom.remove(el));\n    });\n  };\n}\n\nexport const SERVER_TRANSITION_PROVIDERS: StaticProvider[] = [\n  {\n    provide: APP_INITIALIZER,\n    useFactory: appInitializerFactory,\n    deps: [TRANSITION_ID, DOCUMENT, Injector],\n    multi: true\n  },\n];\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {GetTestability, Testability, TestabilityRegistry, setTestabilityGetter, Éµglobal as global} from '@angular/core';\n\nimport {getDOM} from '../dom/dom_adapter';\n\nexport class BrowserGetTestability implements GetTestability {\n  static init() { setTestabilityGetter(new BrowserGetTestability()); }\n\n  addToWindow(registry: TestabilityRegistry): void {\n    global['getAngularTestability'] = (elem: any, findInAncestors: boolean = true) => {\n      const testability = registry.findTestabilityInTree(elem, findInAncestors);\n      if (testability == null) {\n        throw new Error('Could not find testability for element.');\n      }\n      return testability;\n    };\n\n    global['getAllAngularTestabilities'] = () => registry.getAllTestabilities();\n\n    global['getAllAngularRootElements'] = () => registry.getAllRootElements();\n\n    const whenAllStable = (callback: any /** TODO #9100 */) => {\n      const testabilities = global['getAllAngularTestabilities']();\n      let count = testabilities.length;\n      let didWork = false;\n      const decrement = function(didWork_: any /** TODO #9100 */) {\n        didWork = didWork || didWork_;\n        count--;\n        if (count == 0) {\n          callback(didWork);\n        }\n      };\n      testabilities.forEach(function(testability: any /** TODO #9100 */) {\n        testability.whenStable(decrement);\n      });\n    };\n\n    if (!global['frameworkStabilizers']) {\n      global['frameworkStabilizers'] = [];\n    }\n    global['frameworkStabilizers'].push(whenAllStable);\n  }\n\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null {\n    if (elem == null) {\n      return null;\n    }\n    const t = registry.getTestability(elem);\n    if (t != null) {\n      return t;\n    } else if (!findInAncestors) {\n      return null;\n    }\n    if (getDOM().isShadowRoot(elem)) {\n      return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);\n    }\n    return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Éµglobal as global} from '@angular/core';\n\nconst CAMEL_CASE_REGEXP = /([A-Z])/g;\nconst DASH_CASE_REGEXP = /-([a-z])/g;\n\n\nexport function camelCaseToDashCase(input: string): string {\n  return input.replace(CAMEL_CASE_REGEXP, (...m: string[]) => '-' + m[1].toLowerCase());\n}\n\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: string[]) => m[1].toUpperCase());\n}\n\n/**\n * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if\n * `name` is `'probe'`.\n * @param name Name under which it will be exported. Keep in mind this will be a property of the\n * global `ng` object.\n * @param value The value to export.\n */\nexport function exportNgVar(name: string, value: any): void {\n  if (typeof COMPILED === 'undefined' || !COMPILED) {\n    // Note: we can't export `ng` when using closure enhanced optimization as:\n    // - closure declares globals itself for minified names, which sometimes clobber our `ng` global\n    // - we can't declare a closure extern as the namespace `ng` is already used within Google\n    //   for typings for angularJS (via `goog.provide('ng....')`).\n    const ng = global['ng'] = (global['ng'] as{[key: string]: any} | undefined) || {};\n    ng[name] = value;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {APP_INITIALIZER, ApplicationRef, DebugNode, NgProbeToken, NgZone, Optional, Provider, getDebugNode} from '@angular/core';\n\nimport {exportNgVar} from '../util';\n\nconst CORE_TOKENS = (() => ({\n                       'ApplicationRef': ApplicationRef,\n                       'NgZone': NgZone,\n                     }))();\n\nconst INSPECT_GLOBAL_NAME = 'probe';\nconst CORE_TOKENS_GLOBAL_NAME = 'coreTokens';\n\n/**\n * Returns a {@link DebugElement} for the given native DOM element, or\n * null if the given native element does not have an Angular view associated\n * with it.\n */\nexport function inspectNativeElement(element: any): DebugNode|null {\n  return getDebugNode(element);\n}\n\nexport function _createNgProbe(coreTokens: NgProbeToken[]): any {\n  exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElement);\n  exportNgVar(CORE_TOKENS_GLOBAL_NAME, {...CORE_TOKENS, ..._ngProbeTokensToMap(coreTokens || [])});\n  return () => inspectNativeElement;\n}\n\nfunction _ngProbeTokensToMap(tokens: NgProbeToken[]): {[name: string]: any} {\n  return tokens.reduce((prev: any, t: any) => (prev[t.name] = t.token, prev), {});\n}\n\n/**\n * In Ivy, we don't support NgProbe because we have our own set of testing utilities\n * with more robust functionality.\n *\n * We shouldn't bring in NgProbe because it prevents DebugNode and friends from\n * tree-shaking properly.\n */\nexport const ELEMENT_PROBE_PROVIDERS__POST_R3__ = [];\n\n/**\n * Providers which support debugging Angular applications (e.g. via `ng.probe`).\n */\nexport const ELEMENT_PROBE_PROVIDERS__PRE_R3__: Provider[] = [\n  {\n    provide: APP_INITIALIZER,\n    useFactory: _createNgProbe,\n    deps: [\n      [NgProbeToken, new Optional()],\n    ],\n    multi: true,\n  },\n];\n\nexport const ELEMENT_PROBE_PROVIDERS = ELEMENT_PROBE_PROVIDERS__PRE_R3__;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, Injectable, InjectionToken, NgZone} from '@angular/core';\n\nimport {getDOM} from '../dom_adapter';\n\n/**\n * The injection token for the event-manager plug-in service.\n *\n * @publicApi\n */\nexport const EVENT_MANAGER_PLUGINS =\n    new InjectionToken<EventManagerPlugin[]>('EventManagerPlugins');\n\n/**\n * An injectable service that provides event management for Angular\n * through a browser plug-in.\n *\n * @publicApi\n */\n@Injectable()\nexport class EventManager {\n  private _plugins: EventManagerPlugin[];\n  private _eventNameToPlugin = new Map<string, EventManagerPlugin>();\n\n  /**\n   * Initializes an instance of the event-manager service.\n   */\n  constructor(@Inject(EVENT_MANAGER_PLUGINS) plugins: EventManagerPlugin[], private _zone: NgZone) {\n    plugins.forEach(p => p.manager = this);\n    this._plugins = plugins.slice().reverse();\n  }\n\n  /**\n   * Registers a handler for a specific element and event.\n   *\n   * @param element The HTML element to receive event notifications.\n   * @param eventName The name of the event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @returns  A callback function that can be used to remove the handler.\n   */\n  addEventListener(element: HTMLElement, eventName: string, handler: Function): Function {\n    const plugin = this._findPluginFor(eventName);\n    return plugin.addEventListener(element, eventName, handler);\n  }\n\n  /**\n   * Registers a global handler for an event in a target view.\n   *\n   * @param target A target for global event notifications. One of \"window\", \"document\", or \"body\".\n   * @param eventName The name of the event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @returns A callback function that can be used to remove the handler.\n   */\n  addGlobalEventListener(target: string, eventName: string, handler: Function): Function {\n    const plugin = this._findPluginFor(eventName);\n    return plugin.addGlobalEventListener(target, eventName, handler);\n  }\n\n  /**\n   * Retrieves the compilation zone in which event listeners are registered.\n   */\n  getZone(): NgZone { return this._zone; }\n\n  /** @internal */\n  _findPluginFor(eventName: string): EventManagerPlugin {\n    const plugin = this._eventNameToPlugin.get(eventName);\n    if (plugin) {\n      return plugin;\n    }\n\n    const plugins = this._plugins;\n    for (let i = 0; i < plugins.length; i++) {\n      const plugin = plugins[i];\n      if (plugin.supports(eventName)) {\n        this._eventNameToPlugin.set(eventName, plugin);\n        return plugin;\n      }\n    }\n    throw new Error(`No event manager plugin found for event ${eventName}`);\n  }\n}\n\nexport abstract class EventManagerPlugin {\n  constructor(private _doc: any) {}\n\n  // TODO(issue/24571): remove '!'.\n  manager !: EventManager;\n\n  abstract supports(eventName: string): boolean;\n\n  abstract addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;\n\n  addGlobalEventListener(element: string, eventName: string, handler: Function): Function {\n    const target: HTMLElement = getDOM().getGlobalEventTarget(this._doc, element);\n    if (!target) {\n      throw new Error(`Unsupported event target ${target} for event ${eventName}`);\n    }\n    return this.addEventListener(target, eventName, handler);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, OnDestroy} from '@angular/core';\nimport {getDOM} from './dom_adapter';\n\n@Injectable()\nexport class SharedStylesHost {\n  /** @internal */\n  protected _stylesSet = new Set<string>();\n\n  addStyles(styles: string[]): void {\n    const additions = new Set<string>();\n    styles.forEach(style => {\n      if (!this._stylesSet.has(style)) {\n        this._stylesSet.add(style);\n        additions.add(style);\n      }\n    });\n    this.onStylesAdded(additions);\n  }\n\n  onStylesAdded(additions: Set<string>): void {}\n\n  getAllStyles(): string[] { return Array.from(this._stylesSet); }\n}\n\n@Injectable()\nexport class DomSharedStylesHost extends SharedStylesHost implements OnDestroy {\n  private _hostNodes = new Set<Node>();\n  private _styleNodes = new Set<Node>();\n  constructor(@Inject(DOCUMENT) private _doc: any) {\n    super();\n    this._hostNodes.add(_doc.head);\n  }\n\n  private _addStylesToHost(styles: Set<string>, host: Node): void {\n    styles.forEach((style: string) => {\n      const styleEl = this._doc.createElement('style');\n      styleEl.textContent = style;\n      this._styleNodes.add(host.appendChild(styleEl));\n    });\n  }\n\n  addHost(hostNode: Node): void {\n    this._addStylesToHost(this._stylesSet, hostNode);\n    this._hostNodes.add(hostNode);\n  }\n\n  removeHost(hostNode: Node): void { this._hostNodes.delete(hostNode); }\n\n  onStylesAdded(additions: Set<string>): void {\n    this._hostNodes.forEach(hostNode